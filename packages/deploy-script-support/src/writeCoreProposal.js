import fs from 'fs';
import { E } from '@endo/far';
import { deeplyFulfilled, makeMarshal } from '@endo/marshal';
import { decodeToJustin } from '@endo/marshal/src/marshal-justin.js';

const { serialize } = makeMarshal();
const stringify = (x, pretty = undefined) =>
  decodeToJustin(JSON.parse(serialize(harden(x)).body), pretty);

export const makeWriteCoreProposal = (
  homeP,
  endowments,
  { getBundlerMaker, installInPieces },
) => {
  const { board, zoe } = E.get(homeP);
  const { bundleSource, pathResolve } = endowments;

  let bundlerCache;
  const getBundler = () => {
    if (!bundlerCache) {
      bundlerCache = E(getBundlerMaker()).makeBundler({
        zoe,
      });
    }
    return bundlerCache;
  };

  const mergeProposalPermit = async (proposal, additionalManifest) => {
    const {
      sourceSpec,
      getManifestCall: [exportedGetManifest, ...manifestArgs],
    } = proposal;

    const manifestNs = await import(pathResolve(sourceSpec));

    // We only care about the manifest, not any restoreRef calls.
    const { manifest } = await manifestNs[exportedGetManifest](
      { restoreRef: x => `restoreRef:${x}` },
      ...manifestArgs,
    );

    // FIXME: later actually merge the manifest with additionalManifest for
    // minimalistic permit.
    console.log('TODO: would merge', { manifest, additionalManifest });
    return true;
  };

  const writeCoreProposal = async (filePrefix, proposalBuilder) => {
    // Install an entrypoint.
    const install = async entrypoint => {
      const bundler = getBundler();
      const bundle = await bundleSource(pathResolve(entrypoint));
      return installInPieces(bundle, bundler);
    };

    // Await a reference then publish to the board.
    const publishRef = async refP => {
      const ref = await refP;
      return E(board).getId(ref);
    };

    // Create the proposal structure.
    const proposal = await deeplyFulfilled(
      harden(proposalBuilder({ publishRef, install })),
    );
    const { sourceSpec, getManifestCall } = proposal;

    // Extract the top-level permit.
    const t = 'writeCoreProposal';
    const proposalPermit = await mergeProposalPermit(proposal, {
      $writeCoreProposal: {
        consume: { board: t },
        evaluateInstallation: t,
        installation: { produce: t },
        modules: { utils: { runModuleBehaviors: t } },
      },
    });

    // Get an install
    const manifestInstallRef = await publishRef(install(sourceSpec));

    const code = `\
// This is generated by writeCoreProposal; please edit!
/* eslint-disable */

const getManifestCall = harden(${stringify(getManifestCall, true)});
const manifestInstallRef = ${stringify(manifestInstallRef)};

const { entries, fromEntries } = Object;

const shallowFulfilled = async obj => {
  if (!obj) {
    return obj;
  }
  const ents = await Promise.all(entries(obj).map(async ([key, valueP]) => {
    const value = await valueP;
    return [key, value];
  }));
  return fromEntries(ents);
};

const behavior = async (allPowers) => {
  const {
    consume: { board },
    evaluateInstallation,
    installation: { produce: produceInstallations },
    modules: { utils: { runModuleBehaviors }},
  } = allPowers;
  const [exportedGetManifest, ...manifestArgs] = getManifestCall;

  // Get the on-chain installation containing the manifest and behaviors.
  const manifestInstallation = await E(board).getValue(manifestInstallRef);
  const behaviors = await evaluateInstallation(manifestInstallation);

  const restoreRef = x => E(board).getValue(x);
  const { manifest, options: rawOptions, installations: rawInstallations } =
    await behaviors[exportedGetManifest](harden({ restoreRef }), ...manifestArgs);

  // Await references in the options or installations.
  const [options, installations] = await Promise.all(
    [rawOptions, rawInstallations].map(shallowFulfilled),
  );

  // Publish the installations for behavior dependencies.
  entries(installations).forEach(([key, value]) => {
    produceInstallations[key].resolve(value);
  });

  // Evaluate the manifest for our behaviors.
  return runModuleBehaviors({
    allPowers,
    behaviors,
    manifest,
    makeConfig: (name, _permit) => {
      console.info('coreProposal:', name);
      return { options };
    },
  });
};

// Make the behavior the completion value.
behavior;
`;

    // end-of-line whitespace disrupts YAML formatting
    const trimmed = code.replace(/[\r\t ]+$/gm, '');

    const proposalPermitJsonFile = `${filePrefix}-permit.json`;
    console.log(`creating ${proposalPermitJsonFile}`);
    fs.writeFileSync(proposalPermitJsonFile, JSON.stringify(proposalPermit));

    const proposalJsFile = `${filePrefix}.js`;
    console.log(`creating ${proposalJsFile}`);
    fs.writeFileSync(proposalJsFile, trimmed);

    console.log(`\
You can now run a governance submission command like:
  agd tx gov submit-proposal swingset-core-eval ${proposalPermitJsonFile} ${proposalJsFile} \\
    --title="Enable <something>" --description="Evaluate ${proposalJsFile}" --deposit=1000000ubld \\
    --gas=auto --gas-adjustment=1.2
`);
  };

  return writeCoreProposal;
};
