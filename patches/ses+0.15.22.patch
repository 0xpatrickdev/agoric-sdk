diff --git a/node_modules/ses/dist/lockdown.cjs b/node_modules/ses/dist/lockdown.cjs
index a3c3a0e..06b8237 100644
--- a/node_modules/ses/dist/lockdown.cjs
+++ b/node_modules/ses/dist/lockdown.cjs
@@ -147,35 +147,32 @@ const        { prototype: weaksetPrototype}=   WeakSet;$h‍_once.weaksetPrototy
 const        { prototype: functionPrototype}=   Function;$h‍_once.functionPrototype(functionPrototype);
 const        { prototype: promisePrototype}=   Promise;$h‍_once.promisePrototype(promisePrototype);
 
-const        typedArrayPrototype=  getPrototypeOf(Uint8Array.prototype);
+const        typedArrayPrototype=  getPrototypeOf(Uint8Array.prototype);$h‍_once.typedArrayPrototype(typedArrayPrototype);
 
+const { bind}=   functionPrototype;
 /**
  * uncurryThis()
- * This form of uncurry uses Reflect.apply()
- *
- * The original uncurry uses:
- * const bind = Function.prototype.bind;
- * const uncurryThis = bind.bind(bind.call);
+ * Equivalent of: fn => (thisArg, ...args) => apply(fn, thisArg, args)
  *
  * See those reference for a complete explanation:
  * http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
  * which only lives at
  * http://web.archive.org/web/20160805225710/http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
  *
- * @template {Function} F
- * @param {F} fn
- * returns {(thisArg: ThisParameterType<F>, ...args: Parameters<F>) => ReturnType<F>}
- */$h‍_once.typedArrayPrototype(typedArrayPrototype);
-const        uncurryThis=  (fn)=>(thisArg, ...args)=>  apply(fn, thisArg, args);$h‍_once.uncurryThis(uncurryThis);
-
+ * @type {<F extends (this: any, ...args: any[]) => any>(fn: F) => ((thisArg: ThisParameterType<F>, ...args: Parameters<F>) => ReturnType<F>)}
+ */
+const        uncurryThis=  bind.bind(bind.call); // eslint-disable-line @endo/no-polymorphic-call
+$h‍_once.uncurryThis(uncurryThis);
 const        objectHasOwnProperty=  uncurryThis(objectPrototype.hasOwnProperty);
 //
 $h‍_once.objectHasOwnProperty(objectHasOwnProperty);const arrayFilter=uncurryThis(arrayPrototype.filter);$h‍_once.arrayFilter(arrayFilter);
 const        arrayForEach=  uncurryThis(arrayPrototype.forEach);$h‍_once.arrayForEach(arrayForEach);
 const        arrayIncludes=  uncurryThis(arrayPrototype.includes);$h‍_once.arrayIncludes(arrayIncludes);
-const        arrayJoin=  uncurryThis(arrayPrototype.join);$h‍_once.arrayJoin(arrayJoin);
+const        arrayJoin=  uncurryThis(arrayPrototype.join);
+/** @type {<T, U>(thisArg: readonly T[], callbackfn: (value: T, index: number, array: T[]) => U, thisArg?: any) => U[]} */$h‍_once.arrayJoin(arrayJoin);
 const        arrayMap=  uncurryThis(arrayPrototype.map);$h‍_once.arrayMap(arrayMap);
-const        arrayPop=  uncurryThis(arrayPrototype.pop);$h‍_once.arrayPop(arrayPop);
+const        arrayPop=  uncurryThis(arrayPrototype.pop);
+/** @type {<T>(thisArg: T[], ...items: T[]) => number} */$h‍_once.arrayPop(arrayPop);
 const        arrayPush=  uncurryThis(arrayPrototype.push);$h‍_once.arrayPush(arrayPush);
 const        arraySlice=  uncurryThis(arrayPrototype.slice);$h‍_once.arraySlice(arraySlice);
 const        arraySome=  uncurryThis(arrayPrototype.some);$h‍_once.arraySome(arraySome);
@@ -202,10 +199,17 @@ const        matchAllRegExp=  uncurryThis(regexpPrototype[matchAllSymbol]);
 $h‍_once.matchAllRegExp(matchAllRegExp);const stringEndsWith=uncurryThis(stringPrototype.endsWith);$h‍_once.stringEndsWith(stringEndsWith);
 const        stringIncludes=  uncurryThis(stringPrototype.includes);$h‍_once.stringIncludes(stringIncludes);
 const        stringIndexOf=  uncurryThis(stringPrototype.indexOf);$h‍_once.stringIndexOf(stringIndexOf);
-const        stringMatch=  uncurryThis(stringPrototype.match);$h‍_once.stringMatch(stringMatch);
+const        stringMatch=  uncurryThis(stringPrototype.match);
+/**
+ * @type {
+ *   ((thisArg: string, searchValue: { [Symbol.replace](string: string, replaceValue: string): string; }, replaceValue: string) => string) |
+ *   ((thisArg: string, searchValue: { [Symbol.replace](string: string, replacer: (substring: string, ...args: any[]) => string): string; }, replacer: (substring: string, ...args: any[]) => string) => string)
+ * }
+ */$h‍_once.stringMatch(stringMatch);
 const        stringReplace=  uncurryThis(stringPrototype.replace);$h‍_once.stringReplace(stringReplace);
 const        stringSearch=  uncurryThis(stringPrototype.search);$h‍_once.stringSearch(stringSearch);
-const        stringSlice=  uncurryThis(stringPrototype.slice);$h‍_once.stringSlice(stringSlice);
+const        stringSlice=  uncurryThis(stringPrototype.slice);
+/** @type {(thisArg: string, splitter: string | RegExp | { [Symbol.split](string: string, limit?: number): string[]; }, limit?: number) => string[]} */$h‍_once.stringSlice(stringSlice);
 const        stringSplit=  uncurryThis(stringPrototype.split);$h‍_once.stringSplit(stringSplit);
 const        stringStartsWith=  uncurryThis(stringPrototype.startsWith);$h‍_once.stringStartsWith(stringStartsWith);
 const        iterateString=  uncurryThis(stringPrototype[iteratorSymbol]);
@@ -224,7 +228,8 @@ $h‍_once.weaksetHas(weaksetHas);const functionToString=uncurryThis(functionPro
 //
 $h‍_once.functionToString(functionToString);const{all}=Promise;
 const        promiseAll=  (promises)=>apply(all, Promise, [promises]);$h‍_once.promiseAll(promiseAll);
-const        promiseCatch=  uncurryThis(promisePrototype.catch);$h‍_once.promiseCatch(promiseCatch);
+const        promiseCatch=  uncurryThis(promisePrototype.catch);
+/** @type {<T, TResult1 = T, TResult2 = never>(thisArg: T, onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null) => Promise<TResult1 | TResult2>} */$h‍_once.promiseCatch(promiseCatch);
 const        promiseThen=  uncurryThis(promisePrototype.then);
 //
 $h‍_once.promiseThen(promiseThen);const finalizationRegistryRegister=
@@ -412,7 +417,7 @@ const        noEvalEvaluate=  ()=>  {
 /**
  * Joins English terms with commas and an optional conjunction.
  *
- * @param {string[]} terms
+ * @param {(string | StringablePayload)[]} terms
  * @param {"and" | "or"} conjunction
  */
 const        enJoin=  (terms, conjunction)=>  {
@@ -5318,7 +5323,10 @@ const        CompartmentPrototype=  {
       ()=>  {
         // The namespace box is a contentious design and likely to be a breaking
         // change in an appropriately numbered future version.
-        const namespace=  compartmentImportNow(this, specifier);
+        const namespace=  compartmentImportNow(
+          /** @type {Compartment} */  this,
+          specifier);
+
         return { namespace};
        });
 
@@ -5341,7 +5349,7 @@ const        CompartmentPrototype=  {
 
     assertModuleHooks(this);
 
-    return compartmentImportNow(this, specifier);
+    return compartmentImportNow(/** @type {Compartment} */  this,  specifier);
    }};$h‍_once.CompartmentPrototype(CompartmentPrototype);
 
 
@@ -6539,9 +6547,9 @@ const makeCausalConsole=  (baseConsole, loggedErrorHandler)=>  {
     const levelMethod=  (...logArgs)=>  {
       const subErrors=  [];
       const argTags=  extractErrorArgs(logArgs, subErrors);
-      // @ts-ignore
       // eslint-disable-next-line @endo/no-polymorphic-call
       baseConsole[level](...argTags);
+      // @ts-expect-error ConsoleProp vs LogSeverity mismatch
       logSubErrors(level, subErrors);
      };
     defineProperty(levelMethod, 'name', { value: level});
@@ -6666,7 +6674,7 @@ const        makeRejectionHandlers=  (reportReason)=>{
    * @param {ReasonId} heldReasonId
    */
   const finalizeDroppedPromise=  (heldReasonId)=>{
-    if( mapHas(idToReason)) {
+    if( mapHas(idToReason, heldReasonId)) {
       const reason=  mapGet(idToReason, heldReasonId);
       removeReasonId(heldReasonId);
       reportReason(reason);
diff --git a/node_modules/ses/dist/lockdown.mjs b/node_modules/ses/dist/lockdown.mjs
index a3c3a0e..06b8237 100644
--- a/node_modules/ses/dist/lockdown.mjs
+++ b/node_modules/ses/dist/lockdown.mjs
@@ -147,35 +147,32 @@ const        { prototype: weaksetPrototype}=   WeakSet;$h‍_once.weaksetPrototy
 const        { prototype: functionPrototype}=   Function;$h‍_once.functionPrototype(functionPrototype);
 const        { prototype: promisePrototype}=   Promise;$h‍_once.promisePrototype(promisePrototype);
 
-const        typedArrayPrototype=  getPrototypeOf(Uint8Array.prototype);
+const        typedArrayPrototype=  getPrototypeOf(Uint8Array.prototype);$h‍_once.typedArrayPrototype(typedArrayPrototype);
 
+const { bind}=   functionPrototype;
 /**
  * uncurryThis()
- * This form of uncurry uses Reflect.apply()
- *
- * The original uncurry uses:
- * const bind = Function.prototype.bind;
- * const uncurryThis = bind.bind(bind.call);
+ * Equivalent of: fn => (thisArg, ...args) => apply(fn, thisArg, args)
  *
  * See those reference for a complete explanation:
  * http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
  * which only lives at
  * http://web.archive.org/web/20160805225710/http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
  *
- * @template {Function} F
- * @param {F} fn
- * returns {(thisArg: ThisParameterType<F>, ...args: Parameters<F>) => ReturnType<F>}
- */$h‍_once.typedArrayPrototype(typedArrayPrototype);
-const        uncurryThis=  (fn)=>(thisArg, ...args)=>  apply(fn, thisArg, args);$h‍_once.uncurryThis(uncurryThis);
-
+ * @type {<F extends (this: any, ...args: any[]) => any>(fn: F) => ((thisArg: ThisParameterType<F>, ...args: Parameters<F>) => ReturnType<F>)}
+ */
+const        uncurryThis=  bind.bind(bind.call); // eslint-disable-line @endo/no-polymorphic-call
+$h‍_once.uncurryThis(uncurryThis);
 const        objectHasOwnProperty=  uncurryThis(objectPrototype.hasOwnProperty);
 //
 $h‍_once.objectHasOwnProperty(objectHasOwnProperty);const arrayFilter=uncurryThis(arrayPrototype.filter);$h‍_once.arrayFilter(arrayFilter);
 const        arrayForEach=  uncurryThis(arrayPrototype.forEach);$h‍_once.arrayForEach(arrayForEach);
 const        arrayIncludes=  uncurryThis(arrayPrototype.includes);$h‍_once.arrayIncludes(arrayIncludes);
-const        arrayJoin=  uncurryThis(arrayPrototype.join);$h‍_once.arrayJoin(arrayJoin);
+const        arrayJoin=  uncurryThis(arrayPrototype.join);
+/** @type {<T, U>(thisArg: readonly T[], callbackfn: (value: T, index: number, array: T[]) => U, thisArg?: any) => U[]} */$h‍_once.arrayJoin(arrayJoin);
 const        arrayMap=  uncurryThis(arrayPrototype.map);$h‍_once.arrayMap(arrayMap);
-const        arrayPop=  uncurryThis(arrayPrototype.pop);$h‍_once.arrayPop(arrayPop);
+const        arrayPop=  uncurryThis(arrayPrototype.pop);
+/** @type {<T>(thisArg: T[], ...items: T[]) => number} */$h‍_once.arrayPop(arrayPop);
 const        arrayPush=  uncurryThis(arrayPrototype.push);$h‍_once.arrayPush(arrayPush);
 const        arraySlice=  uncurryThis(arrayPrototype.slice);$h‍_once.arraySlice(arraySlice);
 const        arraySome=  uncurryThis(arrayPrototype.some);$h‍_once.arraySome(arraySome);
@@ -202,10 +199,17 @@ const        matchAllRegExp=  uncurryThis(regexpPrototype[matchAllSymbol]);
 $h‍_once.matchAllRegExp(matchAllRegExp);const stringEndsWith=uncurryThis(stringPrototype.endsWith);$h‍_once.stringEndsWith(stringEndsWith);
 const        stringIncludes=  uncurryThis(stringPrototype.includes);$h‍_once.stringIncludes(stringIncludes);
 const        stringIndexOf=  uncurryThis(stringPrototype.indexOf);$h‍_once.stringIndexOf(stringIndexOf);
-const        stringMatch=  uncurryThis(stringPrototype.match);$h‍_once.stringMatch(stringMatch);
+const        stringMatch=  uncurryThis(stringPrototype.match);
+/**
+ * @type {
+ *   ((thisArg: string, searchValue: { [Symbol.replace](string: string, replaceValue: string): string; }, replaceValue: string) => string) |
+ *   ((thisArg: string, searchValue: { [Symbol.replace](string: string, replacer: (substring: string, ...args: any[]) => string): string; }, replacer: (substring: string, ...args: any[]) => string) => string)
+ * }
+ */$h‍_once.stringMatch(stringMatch);
 const        stringReplace=  uncurryThis(stringPrototype.replace);$h‍_once.stringReplace(stringReplace);
 const        stringSearch=  uncurryThis(stringPrototype.search);$h‍_once.stringSearch(stringSearch);
-const        stringSlice=  uncurryThis(stringPrototype.slice);$h‍_once.stringSlice(stringSlice);
+const        stringSlice=  uncurryThis(stringPrototype.slice);
+/** @type {(thisArg: string, splitter: string | RegExp | { [Symbol.split](string: string, limit?: number): string[]; }, limit?: number) => string[]} */$h‍_once.stringSlice(stringSlice);
 const        stringSplit=  uncurryThis(stringPrototype.split);$h‍_once.stringSplit(stringSplit);
 const        stringStartsWith=  uncurryThis(stringPrototype.startsWith);$h‍_once.stringStartsWith(stringStartsWith);
 const        iterateString=  uncurryThis(stringPrototype[iteratorSymbol]);
@@ -224,7 +228,8 @@ $h‍_once.weaksetHas(weaksetHas);const functionToString=uncurryThis(functionPro
 //
 $h‍_once.functionToString(functionToString);const{all}=Promise;
 const        promiseAll=  (promises)=>apply(all, Promise, [promises]);$h‍_once.promiseAll(promiseAll);
-const        promiseCatch=  uncurryThis(promisePrototype.catch);$h‍_once.promiseCatch(promiseCatch);
+const        promiseCatch=  uncurryThis(promisePrototype.catch);
+/** @type {<T, TResult1 = T, TResult2 = never>(thisArg: T, onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null) => Promise<TResult1 | TResult2>} */$h‍_once.promiseCatch(promiseCatch);
 const        promiseThen=  uncurryThis(promisePrototype.then);
 //
 $h‍_once.promiseThen(promiseThen);const finalizationRegistryRegister=
@@ -412,7 +417,7 @@ const        noEvalEvaluate=  ()=>  {
 /**
  * Joins English terms with commas and an optional conjunction.
  *
- * @param {string[]} terms
+ * @param {(string | StringablePayload)[]} terms
  * @param {"and" | "or"} conjunction
  */
 const        enJoin=  (terms, conjunction)=>  {
@@ -5318,7 +5323,10 @@ const        CompartmentPrototype=  {
       ()=>  {
         // The namespace box is a contentious design and likely to be a breaking
         // change in an appropriately numbered future version.
-        const namespace=  compartmentImportNow(this, specifier);
+        const namespace=  compartmentImportNow(
+          /** @type {Compartment} */  this,
+          specifier);
+
         return { namespace};
        });
 
@@ -5341,7 +5349,7 @@ const        CompartmentPrototype=  {
 
     assertModuleHooks(this);
 
-    return compartmentImportNow(this, specifier);
+    return compartmentImportNow(/** @type {Compartment} */  this,  specifier);
    }};$h‍_once.CompartmentPrototype(CompartmentPrototype);
 
 
@@ -6539,9 +6547,9 @@ const makeCausalConsole=  (baseConsole, loggedErrorHandler)=>  {
     const levelMethod=  (...logArgs)=>  {
       const subErrors=  [];
       const argTags=  extractErrorArgs(logArgs, subErrors);
-      // @ts-ignore
       // eslint-disable-next-line @endo/no-polymorphic-call
       baseConsole[level](...argTags);
+      // @ts-expect-error ConsoleProp vs LogSeverity mismatch
       logSubErrors(level, subErrors);
      };
     defineProperty(levelMethod, 'name', { value: level});
@@ -6666,7 +6674,7 @@ const        makeRejectionHandlers=  (reportReason)=>{
    * @param {ReasonId} heldReasonId
    */
   const finalizeDroppedPromise=  (heldReasonId)=>{
-    if( mapHas(idToReason)) {
+    if( mapHas(idToReason, heldReasonId)) {
       const reason=  mapGet(idToReason, heldReasonId);
       removeReasonId(heldReasonId);
       reportReason(reason);
diff --git a/node_modules/ses/dist/lockdown.umd.js b/node_modules/ses/dist/lockdown.umd.js
index a3c3a0e..06b8237 100644
--- a/node_modules/ses/dist/lockdown.umd.js
+++ b/node_modules/ses/dist/lockdown.umd.js
@@ -147,35 +147,32 @@ const        { prototype: weaksetPrototype}=   WeakSet;$h‍_once.weaksetPrototy
 const        { prototype: functionPrototype}=   Function;$h‍_once.functionPrototype(functionPrototype);
 const        { prototype: promisePrototype}=   Promise;$h‍_once.promisePrototype(promisePrototype);
 
-const        typedArrayPrototype=  getPrototypeOf(Uint8Array.prototype);
+const        typedArrayPrototype=  getPrototypeOf(Uint8Array.prototype);$h‍_once.typedArrayPrototype(typedArrayPrototype);
 
+const { bind}=   functionPrototype;
 /**
  * uncurryThis()
- * This form of uncurry uses Reflect.apply()
- *
- * The original uncurry uses:
- * const bind = Function.prototype.bind;
- * const uncurryThis = bind.bind(bind.call);
+ * Equivalent of: fn => (thisArg, ...args) => apply(fn, thisArg, args)
  *
  * See those reference for a complete explanation:
  * http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
  * which only lives at
  * http://web.archive.org/web/20160805225710/http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
  *
- * @template {Function} F
- * @param {F} fn
- * returns {(thisArg: ThisParameterType<F>, ...args: Parameters<F>) => ReturnType<F>}
- */$h‍_once.typedArrayPrototype(typedArrayPrototype);
-const        uncurryThis=  (fn)=>(thisArg, ...args)=>  apply(fn, thisArg, args);$h‍_once.uncurryThis(uncurryThis);
-
+ * @type {<F extends (this: any, ...args: any[]) => any>(fn: F) => ((thisArg: ThisParameterType<F>, ...args: Parameters<F>) => ReturnType<F>)}
+ */
+const        uncurryThis=  bind.bind(bind.call); // eslint-disable-line @endo/no-polymorphic-call
+$h‍_once.uncurryThis(uncurryThis);
 const        objectHasOwnProperty=  uncurryThis(objectPrototype.hasOwnProperty);
 //
 $h‍_once.objectHasOwnProperty(objectHasOwnProperty);const arrayFilter=uncurryThis(arrayPrototype.filter);$h‍_once.arrayFilter(arrayFilter);
 const        arrayForEach=  uncurryThis(arrayPrototype.forEach);$h‍_once.arrayForEach(arrayForEach);
 const        arrayIncludes=  uncurryThis(arrayPrototype.includes);$h‍_once.arrayIncludes(arrayIncludes);
-const        arrayJoin=  uncurryThis(arrayPrototype.join);$h‍_once.arrayJoin(arrayJoin);
+const        arrayJoin=  uncurryThis(arrayPrototype.join);
+/** @type {<T, U>(thisArg: readonly T[], callbackfn: (value: T, index: number, array: T[]) => U, thisArg?: any) => U[]} */$h‍_once.arrayJoin(arrayJoin);
 const        arrayMap=  uncurryThis(arrayPrototype.map);$h‍_once.arrayMap(arrayMap);
-const        arrayPop=  uncurryThis(arrayPrototype.pop);$h‍_once.arrayPop(arrayPop);
+const        arrayPop=  uncurryThis(arrayPrototype.pop);
+/** @type {<T>(thisArg: T[], ...items: T[]) => number} */$h‍_once.arrayPop(arrayPop);
 const        arrayPush=  uncurryThis(arrayPrototype.push);$h‍_once.arrayPush(arrayPush);
 const        arraySlice=  uncurryThis(arrayPrototype.slice);$h‍_once.arraySlice(arraySlice);
 const        arraySome=  uncurryThis(arrayPrototype.some);$h‍_once.arraySome(arraySome);
@@ -202,10 +199,17 @@ const        matchAllRegExp=  uncurryThis(regexpPrototype[matchAllSymbol]);
 $h‍_once.matchAllRegExp(matchAllRegExp);const stringEndsWith=uncurryThis(stringPrototype.endsWith);$h‍_once.stringEndsWith(stringEndsWith);
 const        stringIncludes=  uncurryThis(stringPrototype.includes);$h‍_once.stringIncludes(stringIncludes);
 const        stringIndexOf=  uncurryThis(stringPrototype.indexOf);$h‍_once.stringIndexOf(stringIndexOf);
-const        stringMatch=  uncurryThis(stringPrototype.match);$h‍_once.stringMatch(stringMatch);
+const        stringMatch=  uncurryThis(stringPrototype.match);
+/**
+ * @type {
+ *   ((thisArg: string, searchValue: { [Symbol.replace](string: string, replaceValue: string): string; }, replaceValue: string) => string) |
+ *   ((thisArg: string, searchValue: { [Symbol.replace](string: string, replacer: (substring: string, ...args: any[]) => string): string; }, replacer: (substring: string, ...args: any[]) => string) => string)
+ * }
+ */$h‍_once.stringMatch(stringMatch);
 const        stringReplace=  uncurryThis(stringPrototype.replace);$h‍_once.stringReplace(stringReplace);
 const        stringSearch=  uncurryThis(stringPrototype.search);$h‍_once.stringSearch(stringSearch);
-const        stringSlice=  uncurryThis(stringPrototype.slice);$h‍_once.stringSlice(stringSlice);
+const        stringSlice=  uncurryThis(stringPrototype.slice);
+/** @type {(thisArg: string, splitter: string | RegExp | { [Symbol.split](string: string, limit?: number): string[]; }, limit?: number) => string[]} */$h‍_once.stringSlice(stringSlice);
 const        stringSplit=  uncurryThis(stringPrototype.split);$h‍_once.stringSplit(stringSplit);
 const        stringStartsWith=  uncurryThis(stringPrototype.startsWith);$h‍_once.stringStartsWith(stringStartsWith);
 const        iterateString=  uncurryThis(stringPrototype[iteratorSymbol]);
@@ -224,7 +228,8 @@ $h‍_once.weaksetHas(weaksetHas);const functionToString=uncurryThis(functionPro
 //
 $h‍_once.functionToString(functionToString);const{all}=Promise;
 const        promiseAll=  (promises)=>apply(all, Promise, [promises]);$h‍_once.promiseAll(promiseAll);
-const        promiseCatch=  uncurryThis(promisePrototype.catch);$h‍_once.promiseCatch(promiseCatch);
+const        promiseCatch=  uncurryThis(promisePrototype.catch);
+/** @type {<T, TResult1 = T, TResult2 = never>(thisArg: T, onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null) => Promise<TResult1 | TResult2>} */$h‍_once.promiseCatch(promiseCatch);
 const        promiseThen=  uncurryThis(promisePrototype.then);
 //
 $h‍_once.promiseThen(promiseThen);const finalizationRegistryRegister=
@@ -412,7 +417,7 @@ const        noEvalEvaluate=  ()=>  {
 /**
  * Joins English terms with commas and an optional conjunction.
  *
- * @param {string[]} terms
+ * @param {(string | StringablePayload)[]} terms
  * @param {"and" | "or"} conjunction
  */
 const        enJoin=  (terms, conjunction)=>  {
@@ -5318,7 +5323,10 @@ const        CompartmentPrototype=  {
       ()=>  {
         // The namespace box is a contentious design and likely to be a breaking
         // change in an appropriately numbered future version.
-        const namespace=  compartmentImportNow(this, specifier);
+        const namespace=  compartmentImportNow(
+          /** @type {Compartment} */  this,
+          specifier);
+
         return { namespace};
        });
 
@@ -5341,7 +5349,7 @@ const        CompartmentPrototype=  {
 
     assertModuleHooks(this);
 
-    return compartmentImportNow(this, specifier);
+    return compartmentImportNow(/** @type {Compartment} */  this,  specifier);
    }};$h‍_once.CompartmentPrototype(CompartmentPrototype);
 
 
@@ -6539,9 +6547,9 @@ const makeCausalConsole=  (baseConsole, loggedErrorHandler)=>  {
     const levelMethod=  (...logArgs)=>  {
       const subErrors=  [];
       const argTags=  extractErrorArgs(logArgs, subErrors);
-      // @ts-ignore
       // eslint-disable-next-line @endo/no-polymorphic-call
       baseConsole[level](...argTags);
+      // @ts-expect-error ConsoleProp vs LogSeverity mismatch
       logSubErrors(level, subErrors);
      };
     defineProperty(levelMethod, 'name', { value: level});
@@ -6666,7 +6674,7 @@ const        makeRejectionHandlers=  (reportReason)=>{
    * @param {ReasonId} heldReasonId
    */
   const finalizeDroppedPromise=  (heldReasonId)=>{
-    if( mapHas(idToReason)) {
+    if( mapHas(idToReason, heldReasonId)) {
       const reason=  mapGet(idToReason, heldReasonId);
       removeReasonId(heldReasonId);
       reportReason(reason);
diff --git a/node_modules/ses/dist/ses.cjs b/node_modules/ses/dist/ses.cjs
index a3c3a0e..06b8237 100644
--- a/node_modules/ses/dist/ses.cjs
+++ b/node_modules/ses/dist/ses.cjs
@@ -147,35 +147,32 @@ const        { prototype: weaksetPrototype}=   WeakSet;$h‍_once.weaksetPrototy
 const        { prototype: functionPrototype}=   Function;$h‍_once.functionPrototype(functionPrototype);
 const        { prototype: promisePrototype}=   Promise;$h‍_once.promisePrototype(promisePrototype);
 
-const        typedArrayPrototype=  getPrototypeOf(Uint8Array.prototype);
+const        typedArrayPrototype=  getPrototypeOf(Uint8Array.prototype);$h‍_once.typedArrayPrototype(typedArrayPrototype);
 
+const { bind}=   functionPrototype;
 /**
  * uncurryThis()
- * This form of uncurry uses Reflect.apply()
- *
- * The original uncurry uses:
- * const bind = Function.prototype.bind;
- * const uncurryThis = bind.bind(bind.call);
+ * Equivalent of: fn => (thisArg, ...args) => apply(fn, thisArg, args)
  *
  * See those reference for a complete explanation:
  * http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
  * which only lives at
  * http://web.archive.org/web/20160805225710/http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
  *
- * @template {Function} F
- * @param {F} fn
- * returns {(thisArg: ThisParameterType<F>, ...args: Parameters<F>) => ReturnType<F>}
- */$h‍_once.typedArrayPrototype(typedArrayPrototype);
-const        uncurryThis=  (fn)=>(thisArg, ...args)=>  apply(fn, thisArg, args);$h‍_once.uncurryThis(uncurryThis);
-
+ * @type {<F extends (this: any, ...args: any[]) => any>(fn: F) => ((thisArg: ThisParameterType<F>, ...args: Parameters<F>) => ReturnType<F>)}
+ */
+const        uncurryThis=  bind.bind(bind.call); // eslint-disable-line @endo/no-polymorphic-call
+$h‍_once.uncurryThis(uncurryThis);
 const        objectHasOwnProperty=  uncurryThis(objectPrototype.hasOwnProperty);
 //
 $h‍_once.objectHasOwnProperty(objectHasOwnProperty);const arrayFilter=uncurryThis(arrayPrototype.filter);$h‍_once.arrayFilter(arrayFilter);
 const        arrayForEach=  uncurryThis(arrayPrototype.forEach);$h‍_once.arrayForEach(arrayForEach);
 const        arrayIncludes=  uncurryThis(arrayPrototype.includes);$h‍_once.arrayIncludes(arrayIncludes);
-const        arrayJoin=  uncurryThis(arrayPrototype.join);$h‍_once.arrayJoin(arrayJoin);
+const        arrayJoin=  uncurryThis(arrayPrototype.join);
+/** @type {<T, U>(thisArg: readonly T[], callbackfn: (value: T, index: number, array: T[]) => U, thisArg?: any) => U[]} */$h‍_once.arrayJoin(arrayJoin);
 const        arrayMap=  uncurryThis(arrayPrototype.map);$h‍_once.arrayMap(arrayMap);
-const        arrayPop=  uncurryThis(arrayPrototype.pop);$h‍_once.arrayPop(arrayPop);
+const        arrayPop=  uncurryThis(arrayPrototype.pop);
+/** @type {<T>(thisArg: T[], ...items: T[]) => number} */$h‍_once.arrayPop(arrayPop);
 const        arrayPush=  uncurryThis(arrayPrototype.push);$h‍_once.arrayPush(arrayPush);
 const        arraySlice=  uncurryThis(arrayPrototype.slice);$h‍_once.arraySlice(arraySlice);
 const        arraySome=  uncurryThis(arrayPrototype.some);$h‍_once.arraySome(arraySome);
@@ -202,10 +199,17 @@ const        matchAllRegExp=  uncurryThis(regexpPrototype[matchAllSymbol]);
 $h‍_once.matchAllRegExp(matchAllRegExp);const stringEndsWith=uncurryThis(stringPrototype.endsWith);$h‍_once.stringEndsWith(stringEndsWith);
 const        stringIncludes=  uncurryThis(stringPrototype.includes);$h‍_once.stringIncludes(stringIncludes);
 const        stringIndexOf=  uncurryThis(stringPrototype.indexOf);$h‍_once.stringIndexOf(stringIndexOf);
-const        stringMatch=  uncurryThis(stringPrototype.match);$h‍_once.stringMatch(stringMatch);
+const        stringMatch=  uncurryThis(stringPrototype.match);
+/**
+ * @type {
+ *   ((thisArg: string, searchValue: { [Symbol.replace](string: string, replaceValue: string): string; }, replaceValue: string) => string) |
+ *   ((thisArg: string, searchValue: { [Symbol.replace](string: string, replacer: (substring: string, ...args: any[]) => string): string; }, replacer: (substring: string, ...args: any[]) => string) => string)
+ * }
+ */$h‍_once.stringMatch(stringMatch);
 const        stringReplace=  uncurryThis(stringPrototype.replace);$h‍_once.stringReplace(stringReplace);
 const        stringSearch=  uncurryThis(stringPrototype.search);$h‍_once.stringSearch(stringSearch);
-const        stringSlice=  uncurryThis(stringPrototype.slice);$h‍_once.stringSlice(stringSlice);
+const        stringSlice=  uncurryThis(stringPrototype.slice);
+/** @type {(thisArg: string, splitter: string | RegExp | { [Symbol.split](string: string, limit?: number): string[]; }, limit?: number) => string[]} */$h‍_once.stringSlice(stringSlice);
 const        stringSplit=  uncurryThis(stringPrototype.split);$h‍_once.stringSplit(stringSplit);
 const        stringStartsWith=  uncurryThis(stringPrototype.startsWith);$h‍_once.stringStartsWith(stringStartsWith);
 const        iterateString=  uncurryThis(stringPrototype[iteratorSymbol]);
@@ -224,7 +228,8 @@ $h‍_once.weaksetHas(weaksetHas);const functionToString=uncurryThis(functionPro
 //
 $h‍_once.functionToString(functionToString);const{all}=Promise;
 const        promiseAll=  (promises)=>apply(all, Promise, [promises]);$h‍_once.promiseAll(promiseAll);
-const        promiseCatch=  uncurryThis(promisePrototype.catch);$h‍_once.promiseCatch(promiseCatch);
+const        promiseCatch=  uncurryThis(promisePrototype.catch);
+/** @type {<T, TResult1 = T, TResult2 = never>(thisArg: T, onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null) => Promise<TResult1 | TResult2>} */$h‍_once.promiseCatch(promiseCatch);
 const        promiseThen=  uncurryThis(promisePrototype.then);
 //
 $h‍_once.promiseThen(promiseThen);const finalizationRegistryRegister=
@@ -412,7 +417,7 @@ const        noEvalEvaluate=  ()=>  {
 /**
  * Joins English terms with commas and an optional conjunction.
  *
- * @param {string[]} terms
+ * @param {(string | StringablePayload)[]} terms
  * @param {"and" | "or"} conjunction
  */
 const        enJoin=  (terms, conjunction)=>  {
@@ -5318,7 +5323,10 @@ const        CompartmentPrototype=  {
       ()=>  {
         // The namespace box is a contentious design and likely to be a breaking
         // change in an appropriately numbered future version.
-        const namespace=  compartmentImportNow(this, specifier);
+        const namespace=  compartmentImportNow(
+          /** @type {Compartment} */  this,
+          specifier);
+
         return { namespace};
        });
 
@@ -5341,7 +5349,7 @@ const        CompartmentPrototype=  {
 
     assertModuleHooks(this);
 
-    return compartmentImportNow(this, specifier);
+    return compartmentImportNow(/** @type {Compartment} */  this,  specifier);
    }};$h‍_once.CompartmentPrototype(CompartmentPrototype);
 
 
@@ -6539,9 +6547,9 @@ const makeCausalConsole=  (baseConsole, loggedErrorHandler)=>  {
     const levelMethod=  (...logArgs)=>  {
       const subErrors=  [];
       const argTags=  extractErrorArgs(logArgs, subErrors);
-      // @ts-ignore
       // eslint-disable-next-line @endo/no-polymorphic-call
       baseConsole[level](...argTags);
+      // @ts-expect-error ConsoleProp vs LogSeverity mismatch
       logSubErrors(level, subErrors);
      };
     defineProperty(levelMethod, 'name', { value: level});
@@ -6666,7 +6674,7 @@ const        makeRejectionHandlers=  (reportReason)=>{
    * @param {ReasonId} heldReasonId
    */
   const finalizeDroppedPromise=  (heldReasonId)=>{
-    if( mapHas(idToReason)) {
+    if( mapHas(idToReason, heldReasonId)) {
       const reason=  mapGet(idToReason, heldReasonId);
       removeReasonId(heldReasonId);
       reportReason(reason);
diff --git a/node_modules/ses/dist/ses.mjs b/node_modules/ses/dist/ses.mjs
index a3c3a0e..06b8237 100644
--- a/node_modules/ses/dist/ses.mjs
+++ b/node_modules/ses/dist/ses.mjs
@@ -147,35 +147,32 @@ const        { prototype: weaksetPrototype}=   WeakSet;$h‍_once.weaksetPrototy
 const        { prototype: functionPrototype}=   Function;$h‍_once.functionPrototype(functionPrototype);
 const        { prototype: promisePrototype}=   Promise;$h‍_once.promisePrototype(promisePrototype);
 
-const        typedArrayPrototype=  getPrototypeOf(Uint8Array.prototype);
+const        typedArrayPrototype=  getPrototypeOf(Uint8Array.prototype);$h‍_once.typedArrayPrototype(typedArrayPrototype);
 
+const { bind}=   functionPrototype;
 /**
  * uncurryThis()
- * This form of uncurry uses Reflect.apply()
- *
- * The original uncurry uses:
- * const bind = Function.prototype.bind;
- * const uncurryThis = bind.bind(bind.call);
+ * Equivalent of: fn => (thisArg, ...args) => apply(fn, thisArg, args)
  *
  * See those reference for a complete explanation:
  * http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
  * which only lives at
  * http://web.archive.org/web/20160805225710/http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
  *
- * @template {Function} F
- * @param {F} fn
- * returns {(thisArg: ThisParameterType<F>, ...args: Parameters<F>) => ReturnType<F>}
- */$h‍_once.typedArrayPrototype(typedArrayPrototype);
-const        uncurryThis=  (fn)=>(thisArg, ...args)=>  apply(fn, thisArg, args);$h‍_once.uncurryThis(uncurryThis);
-
+ * @type {<F extends (this: any, ...args: any[]) => any>(fn: F) => ((thisArg: ThisParameterType<F>, ...args: Parameters<F>) => ReturnType<F>)}
+ */
+const        uncurryThis=  bind.bind(bind.call); // eslint-disable-line @endo/no-polymorphic-call
+$h‍_once.uncurryThis(uncurryThis);
 const        objectHasOwnProperty=  uncurryThis(objectPrototype.hasOwnProperty);
 //
 $h‍_once.objectHasOwnProperty(objectHasOwnProperty);const arrayFilter=uncurryThis(arrayPrototype.filter);$h‍_once.arrayFilter(arrayFilter);
 const        arrayForEach=  uncurryThis(arrayPrototype.forEach);$h‍_once.arrayForEach(arrayForEach);
 const        arrayIncludes=  uncurryThis(arrayPrototype.includes);$h‍_once.arrayIncludes(arrayIncludes);
-const        arrayJoin=  uncurryThis(arrayPrototype.join);$h‍_once.arrayJoin(arrayJoin);
+const        arrayJoin=  uncurryThis(arrayPrototype.join);
+/** @type {<T, U>(thisArg: readonly T[], callbackfn: (value: T, index: number, array: T[]) => U, thisArg?: any) => U[]} */$h‍_once.arrayJoin(arrayJoin);
 const        arrayMap=  uncurryThis(arrayPrototype.map);$h‍_once.arrayMap(arrayMap);
-const        arrayPop=  uncurryThis(arrayPrototype.pop);$h‍_once.arrayPop(arrayPop);
+const        arrayPop=  uncurryThis(arrayPrototype.pop);
+/** @type {<T>(thisArg: T[], ...items: T[]) => number} */$h‍_once.arrayPop(arrayPop);
 const        arrayPush=  uncurryThis(arrayPrototype.push);$h‍_once.arrayPush(arrayPush);
 const        arraySlice=  uncurryThis(arrayPrototype.slice);$h‍_once.arraySlice(arraySlice);
 const        arraySome=  uncurryThis(arrayPrototype.some);$h‍_once.arraySome(arraySome);
@@ -202,10 +199,17 @@ const        matchAllRegExp=  uncurryThis(regexpPrototype[matchAllSymbol]);
 $h‍_once.matchAllRegExp(matchAllRegExp);const stringEndsWith=uncurryThis(stringPrototype.endsWith);$h‍_once.stringEndsWith(stringEndsWith);
 const        stringIncludes=  uncurryThis(stringPrototype.includes);$h‍_once.stringIncludes(stringIncludes);
 const        stringIndexOf=  uncurryThis(stringPrototype.indexOf);$h‍_once.stringIndexOf(stringIndexOf);
-const        stringMatch=  uncurryThis(stringPrototype.match);$h‍_once.stringMatch(stringMatch);
+const        stringMatch=  uncurryThis(stringPrototype.match);
+/**
+ * @type {
+ *   ((thisArg: string, searchValue: { [Symbol.replace](string: string, replaceValue: string): string; }, replaceValue: string) => string) |
+ *   ((thisArg: string, searchValue: { [Symbol.replace](string: string, replacer: (substring: string, ...args: any[]) => string): string; }, replacer: (substring: string, ...args: any[]) => string) => string)
+ * }
+ */$h‍_once.stringMatch(stringMatch);
 const        stringReplace=  uncurryThis(stringPrototype.replace);$h‍_once.stringReplace(stringReplace);
 const        stringSearch=  uncurryThis(stringPrototype.search);$h‍_once.stringSearch(stringSearch);
-const        stringSlice=  uncurryThis(stringPrototype.slice);$h‍_once.stringSlice(stringSlice);
+const        stringSlice=  uncurryThis(stringPrototype.slice);
+/** @type {(thisArg: string, splitter: string | RegExp | { [Symbol.split](string: string, limit?: number): string[]; }, limit?: number) => string[]} */$h‍_once.stringSlice(stringSlice);
 const        stringSplit=  uncurryThis(stringPrototype.split);$h‍_once.stringSplit(stringSplit);
 const        stringStartsWith=  uncurryThis(stringPrototype.startsWith);$h‍_once.stringStartsWith(stringStartsWith);
 const        iterateString=  uncurryThis(stringPrototype[iteratorSymbol]);
@@ -224,7 +228,8 @@ $h‍_once.weaksetHas(weaksetHas);const functionToString=uncurryThis(functionPro
 //
 $h‍_once.functionToString(functionToString);const{all}=Promise;
 const        promiseAll=  (promises)=>apply(all, Promise, [promises]);$h‍_once.promiseAll(promiseAll);
-const        promiseCatch=  uncurryThis(promisePrototype.catch);$h‍_once.promiseCatch(promiseCatch);
+const        promiseCatch=  uncurryThis(promisePrototype.catch);
+/** @type {<T, TResult1 = T, TResult2 = never>(thisArg: T, onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null) => Promise<TResult1 | TResult2>} */$h‍_once.promiseCatch(promiseCatch);
 const        promiseThen=  uncurryThis(promisePrototype.then);
 //
 $h‍_once.promiseThen(promiseThen);const finalizationRegistryRegister=
@@ -412,7 +417,7 @@ const        noEvalEvaluate=  ()=>  {
 /**
  * Joins English terms with commas and an optional conjunction.
  *
- * @param {string[]} terms
+ * @param {(string | StringablePayload)[]} terms
  * @param {"and" | "or"} conjunction
  */
 const        enJoin=  (terms, conjunction)=>  {
@@ -5318,7 +5323,10 @@ const        CompartmentPrototype=  {
       ()=>  {
         // The namespace box is a contentious design and likely to be a breaking
         // change in an appropriately numbered future version.
-        const namespace=  compartmentImportNow(this, specifier);
+        const namespace=  compartmentImportNow(
+          /** @type {Compartment} */  this,
+          specifier);
+
         return { namespace};
        });
 
@@ -5341,7 +5349,7 @@ const        CompartmentPrototype=  {
 
     assertModuleHooks(this);
 
-    return compartmentImportNow(this, specifier);
+    return compartmentImportNow(/** @type {Compartment} */  this,  specifier);
    }};$h‍_once.CompartmentPrototype(CompartmentPrototype);
 
 
@@ -6539,9 +6547,9 @@ const makeCausalConsole=  (baseConsole, loggedErrorHandler)=>  {
     const levelMethod=  (...logArgs)=>  {
       const subErrors=  [];
       const argTags=  extractErrorArgs(logArgs, subErrors);
-      // @ts-ignore
       // eslint-disable-next-line @endo/no-polymorphic-call
       baseConsole[level](...argTags);
+      // @ts-expect-error ConsoleProp vs LogSeverity mismatch
       logSubErrors(level, subErrors);
      };
     defineProperty(levelMethod, 'name', { value: level});
@@ -6666,7 +6674,7 @@ const        makeRejectionHandlers=  (reportReason)=>{
    * @param {ReasonId} heldReasonId
    */
   const finalizeDroppedPromise=  (heldReasonId)=>{
-    if( mapHas(idToReason)) {
+    if( mapHas(idToReason, heldReasonId)) {
       const reason=  mapGet(idToReason, heldReasonId);
       removeReasonId(heldReasonId);
       reportReason(reason);
diff --git a/node_modules/ses/dist/ses.umd.js b/node_modules/ses/dist/ses.umd.js
index a3c3a0e..06b8237 100644
--- a/node_modules/ses/dist/ses.umd.js
+++ b/node_modules/ses/dist/ses.umd.js
@@ -147,35 +147,32 @@ const        { prototype: weaksetPrototype}=   WeakSet;$h‍_once.weaksetPrototy
 const        { prototype: functionPrototype}=   Function;$h‍_once.functionPrototype(functionPrototype);
 const        { prototype: promisePrototype}=   Promise;$h‍_once.promisePrototype(promisePrototype);
 
-const        typedArrayPrototype=  getPrototypeOf(Uint8Array.prototype);
+const        typedArrayPrototype=  getPrototypeOf(Uint8Array.prototype);$h‍_once.typedArrayPrototype(typedArrayPrototype);
 
+const { bind}=   functionPrototype;
 /**
  * uncurryThis()
- * This form of uncurry uses Reflect.apply()
- *
- * The original uncurry uses:
- * const bind = Function.prototype.bind;
- * const uncurryThis = bind.bind(bind.call);
+ * Equivalent of: fn => (thisArg, ...args) => apply(fn, thisArg, args)
  *
  * See those reference for a complete explanation:
  * http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
  * which only lives at
  * http://web.archive.org/web/20160805225710/http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
  *
- * @template {Function} F
- * @param {F} fn
- * returns {(thisArg: ThisParameterType<F>, ...args: Parameters<F>) => ReturnType<F>}
- */$h‍_once.typedArrayPrototype(typedArrayPrototype);
-const        uncurryThis=  (fn)=>(thisArg, ...args)=>  apply(fn, thisArg, args);$h‍_once.uncurryThis(uncurryThis);
-
+ * @type {<F extends (this: any, ...args: any[]) => any>(fn: F) => ((thisArg: ThisParameterType<F>, ...args: Parameters<F>) => ReturnType<F>)}
+ */
+const        uncurryThis=  bind.bind(bind.call); // eslint-disable-line @endo/no-polymorphic-call
+$h‍_once.uncurryThis(uncurryThis);
 const        objectHasOwnProperty=  uncurryThis(objectPrototype.hasOwnProperty);
 //
 $h‍_once.objectHasOwnProperty(objectHasOwnProperty);const arrayFilter=uncurryThis(arrayPrototype.filter);$h‍_once.arrayFilter(arrayFilter);
 const        arrayForEach=  uncurryThis(arrayPrototype.forEach);$h‍_once.arrayForEach(arrayForEach);
 const        arrayIncludes=  uncurryThis(arrayPrototype.includes);$h‍_once.arrayIncludes(arrayIncludes);
-const        arrayJoin=  uncurryThis(arrayPrototype.join);$h‍_once.arrayJoin(arrayJoin);
+const        arrayJoin=  uncurryThis(arrayPrototype.join);
+/** @type {<T, U>(thisArg: readonly T[], callbackfn: (value: T, index: number, array: T[]) => U, thisArg?: any) => U[]} */$h‍_once.arrayJoin(arrayJoin);
 const        arrayMap=  uncurryThis(arrayPrototype.map);$h‍_once.arrayMap(arrayMap);
-const        arrayPop=  uncurryThis(arrayPrototype.pop);$h‍_once.arrayPop(arrayPop);
+const        arrayPop=  uncurryThis(arrayPrototype.pop);
+/** @type {<T>(thisArg: T[], ...items: T[]) => number} */$h‍_once.arrayPop(arrayPop);
 const        arrayPush=  uncurryThis(arrayPrototype.push);$h‍_once.arrayPush(arrayPush);
 const        arraySlice=  uncurryThis(arrayPrototype.slice);$h‍_once.arraySlice(arraySlice);
 const        arraySome=  uncurryThis(arrayPrototype.some);$h‍_once.arraySome(arraySome);
@@ -202,10 +199,17 @@ const        matchAllRegExp=  uncurryThis(regexpPrototype[matchAllSymbol]);
 $h‍_once.matchAllRegExp(matchAllRegExp);const stringEndsWith=uncurryThis(stringPrototype.endsWith);$h‍_once.stringEndsWith(stringEndsWith);
 const        stringIncludes=  uncurryThis(stringPrototype.includes);$h‍_once.stringIncludes(stringIncludes);
 const        stringIndexOf=  uncurryThis(stringPrototype.indexOf);$h‍_once.stringIndexOf(stringIndexOf);
-const        stringMatch=  uncurryThis(stringPrototype.match);$h‍_once.stringMatch(stringMatch);
+const        stringMatch=  uncurryThis(stringPrototype.match);
+/**
+ * @type {
+ *   ((thisArg: string, searchValue: { [Symbol.replace](string: string, replaceValue: string): string; }, replaceValue: string) => string) |
+ *   ((thisArg: string, searchValue: { [Symbol.replace](string: string, replacer: (substring: string, ...args: any[]) => string): string; }, replacer: (substring: string, ...args: any[]) => string) => string)
+ * }
+ */$h‍_once.stringMatch(stringMatch);
 const        stringReplace=  uncurryThis(stringPrototype.replace);$h‍_once.stringReplace(stringReplace);
 const        stringSearch=  uncurryThis(stringPrototype.search);$h‍_once.stringSearch(stringSearch);
-const        stringSlice=  uncurryThis(stringPrototype.slice);$h‍_once.stringSlice(stringSlice);
+const        stringSlice=  uncurryThis(stringPrototype.slice);
+/** @type {(thisArg: string, splitter: string | RegExp | { [Symbol.split](string: string, limit?: number): string[]; }, limit?: number) => string[]} */$h‍_once.stringSlice(stringSlice);
 const        stringSplit=  uncurryThis(stringPrototype.split);$h‍_once.stringSplit(stringSplit);
 const        stringStartsWith=  uncurryThis(stringPrototype.startsWith);$h‍_once.stringStartsWith(stringStartsWith);
 const        iterateString=  uncurryThis(stringPrototype[iteratorSymbol]);
@@ -224,7 +228,8 @@ $h‍_once.weaksetHas(weaksetHas);const functionToString=uncurryThis(functionPro
 //
 $h‍_once.functionToString(functionToString);const{all}=Promise;
 const        promiseAll=  (promises)=>apply(all, Promise, [promises]);$h‍_once.promiseAll(promiseAll);
-const        promiseCatch=  uncurryThis(promisePrototype.catch);$h‍_once.promiseCatch(promiseCatch);
+const        promiseCatch=  uncurryThis(promisePrototype.catch);
+/** @type {<T, TResult1 = T, TResult2 = never>(thisArg: T, onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null) => Promise<TResult1 | TResult2>} */$h‍_once.promiseCatch(promiseCatch);
 const        promiseThen=  uncurryThis(promisePrototype.then);
 //
 $h‍_once.promiseThen(promiseThen);const finalizationRegistryRegister=
@@ -412,7 +417,7 @@ const        noEvalEvaluate=  ()=>  {
 /**
  * Joins English terms with commas and an optional conjunction.
  *
- * @param {string[]} terms
+ * @param {(string | StringablePayload)[]} terms
  * @param {"and" | "or"} conjunction
  */
 const        enJoin=  (terms, conjunction)=>  {
@@ -5318,7 +5323,10 @@ const        CompartmentPrototype=  {
       ()=>  {
         // The namespace box is a contentious design and likely to be a breaking
         // change in an appropriately numbered future version.
-        const namespace=  compartmentImportNow(this, specifier);
+        const namespace=  compartmentImportNow(
+          /** @type {Compartment} */  this,
+          specifier);
+
         return { namespace};
        });
 
@@ -5341,7 +5349,7 @@ const        CompartmentPrototype=  {
 
     assertModuleHooks(this);
 
-    return compartmentImportNow(this, specifier);
+    return compartmentImportNow(/** @type {Compartment} */  this,  specifier);
    }};$h‍_once.CompartmentPrototype(CompartmentPrototype);
 
 
@@ -6539,9 +6547,9 @@ const makeCausalConsole=  (baseConsole, loggedErrorHandler)=>  {
     const levelMethod=  (...logArgs)=>  {
       const subErrors=  [];
       const argTags=  extractErrorArgs(logArgs, subErrors);
-      // @ts-ignore
       // eslint-disable-next-line @endo/no-polymorphic-call
       baseConsole[level](...argTags);
+      // @ts-expect-error ConsoleProp vs LogSeverity mismatch
       logSubErrors(level, subErrors);
      };
     defineProperty(levelMethod, 'name', { value: level});
@@ -6666,7 +6674,7 @@ const        makeRejectionHandlers=  (reportReason)=>{
    * @param {ReasonId} heldReasonId
    */
   const finalizeDroppedPromise=  (heldReasonId)=>{
-    if( mapHas(idToReason)) {
+    if( mapHas(idToReason, heldReasonId)) {
       const reason=  mapGet(idToReason, heldReasonId);
       removeReasonId(heldReasonId);
       reportReason(reason);
diff --git a/node_modules/ses/src/commons.js b/node_modules/ses/src/commons.js
index 4af9aa8..580af93 100644
--- a/node_modules/ses/src/commons.js
+++ b/node_modules/ses/src/commons.js
@@ -145,24 +145,19 @@ export const { prototype: promisePrototype } = Promise;
 
 export const typedArrayPrototype = getPrototypeOf(Uint8Array.prototype);
 
+const { bind } = functionPrototype;
 /**
  * uncurryThis()
- * This form of uncurry uses Reflect.apply()
- *
- * The original uncurry uses:
- * const bind = Function.prototype.bind;
- * const uncurryThis = bind.bind(bind.call);
+ * Equivalent of: fn => (thisArg, ...args) => apply(fn, thisArg, args)
  *
  * See those reference for a complete explanation:
  * http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
  * which only lives at
  * http://web.archive.org/web/20160805225710/http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
  *
- * @template {Function} F
- * @param {F} fn
- * returns {(thisArg: ThisParameterType<F>, ...args: Parameters<F>) => ReturnType<F>}
+ * @type {<F extends (this: any, ...args: any[]) => any>(fn: F) => ((thisArg: ThisParameterType<F>, ...args: Parameters<F>) => ReturnType<F>)}
  */
-export const uncurryThis = fn => (thisArg, ...args) => apply(fn, thisArg, args);
+export const uncurryThis = bind.bind(bind.call); // eslint-disable-line @endo/no-polymorphic-call
 
 export const objectHasOwnProperty = uncurryThis(objectPrototype.hasOwnProperty);
 //
@@ -170,8 +165,10 @@ export const arrayFilter = uncurryThis(arrayPrototype.filter);
 export const arrayForEach = uncurryThis(arrayPrototype.forEach);
 export const arrayIncludes = uncurryThis(arrayPrototype.includes);
 export const arrayJoin = uncurryThis(arrayPrototype.join);
+/** @type {<T, U>(thisArg: readonly T[], callbackfn: (value: T, index: number, array: T[]) => U, thisArg?: any) => U[]} */
 export const arrayMap = uncurryThis(arrayPrototype.map);
 export const arrayPop = uncurryThis(arrayPrototype.pop);
+/** @type {<T>(thisArg: T[], ...items: T[]) => number} */
 export const arrayPush = uncurryThis(arrayPrototype.push);
 export const arraySlice = uncurryThis(arrayPrototype.slice);
 export const arraySome = uncurryThis(arrayPrototype.some);
@@ -199,9 +196,16 @@ export const stringEndsWith = uncurryThis(stringPrototype.endsWith);
 export const stringIncludes = uncurryThis(stringPrototype.includes);
 export const stringIndexOf = uncurryThis(stringPrototype.indexOf);
 export const stringMatch = uncurryThis(stringPrototype.match);
+/**
+ * @type {
+ *   ((thisArg: string, searchValue: { [Symbol.replace](string: string, replaceValue: string): string; }, replaceValue: string) => string) |
+ *   ((thisArg: string, searchValue: { [Symbol.replace](string: string, replacer: (substring: string, ...args: any[]) => string): string; }, replacer: (substring: string, ...args: any[]) => string) => string)
+ * }
+ */
 export const stringReplace = uncurryThis(stringPrototype.replace);
 export const stringSearch = uncurryThis(stringPrototype.search);
 export const stringSlice = uncurryThis(stringPrototype.slice);
+/** @type {(thisArg: string, splitter: string | RegExp | { [Symbol.split](string: string, limit?: number): string[]; }, limit?: number) => string[]} */
 export const stringSplit = uncurryThis(stringPrototype.split);
 export const stringStartsWith = uncurryThis(stringPrototype.startsWith);
 export const iterateString = uncurryThis(stringPrototype[iteratorSymbol]);
@@ -221,6 +225,7 @@ export const functionToString = uncurryThis(functionPrototype.toString);
 const { all } = Promise;
 export const promiseAll = promises => apply(all, Promise, [promises]);
 export const promiseCatch = uncurryThis(promisePrototype.catch);
+/** @type {<T, TResult1 = T, TResult2 = never>(thisArg: T, onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null) => Promise<TResult1 | TResult2>} */
 export const promiseThen = uncurryThis(promisePrototype.then);
 //
 export const finalizationRegistryRegister =
diff --git a/node_modules/ses/src/compartment-shim.js b/node_modules/ses/src/compartment-shim.js
index f20dab8..7a2390f 100644
--- a/node_modules/ses/src/compartment-shim.js
+++ b/node_modules/ses/src/compartment-shim.js
@@ -154,7 +154,10 @@ export const CompartmentPrototype = {
       () => {
         // The namespace box is a contentious design and likely to be a breaking
         // change in an appropriately numbered future version.
-        const namespace = compartmentImportNow(this, specifier);
+        const namespace = compartmentImportNow(
+          /** @type {Compartment} */ (this),
+          specifier,
+        );
         return { namespace };
       },
     );
@@ -177,7 +180,7 @@ export const CompartmentPrototype = {
 
     assertModuleHooks(this);
 
-    return compartmentImportNow(this, specifier);
+    return compartmentImportNow(/** @type {Compartment} */ (this), specifier);
   },
 };
 
diff --git a/node_modules/ses/src/error/console.js b/node_modules/ses/src/error/console.js
index 8c6750b..e692bc5 100644
--- a/node_modules/ses/src/error/console.js
+++ b/node_modules/ses/src/error/console.js
@@ -322,9 +322,9 @@ const makeCausalConsole = (baseConsole, loggedErrorHandler) => {
     const levelMethod = (...logArgs) => {
       const subErrors = [];
       const argTags = extractErrorArgs(logArgs, subErrors);
-      // @ts-ignore
       // eslint-disable-next-line @endo/no-polymorphic-call
       baseConsole[level](...argTags);
+      // @ts-expect-error ConsoleProp vs LogSeverity mismatch
       logSubErrors(level, subErrors);
     };
     defineProperty(levelMethod, 'name', { value: level });
diff --git a/node_modules/ses/src/error/stringify-utils.js b/node_modules/ses/src/error/stringify-utils.js
index 931a799..7c35f8d 100644
--- a/node_modules/ses/src/error/stringify-utils.js
+++ b/node_modules/ses/src/error/stringify-utils.js
@@ -19,7 +19,7 @@ import {
 /**
  * Joins English terms with commas and an optional conjunction.
  *
- * @param {string[]} terms
+ * @param {(string | StringablePayload)[]} terms
  * @param {"and" | "or"} conjunction
  */
 export const enJoin = (terms, conjunction) => {
diff --git a/node_modules/ses/src/error/unhandled-rejection.js b/node_modules/ses/src/error/unhandled-rejection.js
index bba8a91..45be817 100644
--- a/node_modules/ses/src/error/unhandled-rejection.js
+++ b/node_modules/ses/src/error/unhandled-rejection.js
@@ -63,7 +63,7 @@ export const makeRejectionHandlers = reportReason => {
    * @param {ReasonId} heldReasonId
    */
   const finalizeDroppedPromise = heldReasonId => {
-    if (mapHas(idToReason)) {
+    if (mapHas(idToReason, heldReasonId)) {
       const reason = mapGet(idToReason, heldReasonId);
       removeReasonId(heldReasonId);
       reportReason(reason);
